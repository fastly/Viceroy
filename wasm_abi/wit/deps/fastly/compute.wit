package fastly:api;

interface types {
  // TODO: split this up into function-specific error enums
  variant error {
    /// Unknown error value.
    /// It should be an internal error if this is returned.
    unknown-error,
    /// Generic error value.
    /// This means that some unexpected error occurred during a hostcall.
    generic-error,
    /// Invalid argument.
    invalid-argument,
    /// Invalid handle.
    /// Thrown when a handle is not valid. E.G. No dictionary exists with the given name.
    bad-handle,
    /// Buffer length error.
    /// Thrown when a buffer is the wrong size.
    /// Includes the buffer length that would allow the operation to succeed.
    buffer-len(u64),
    /// Unsupported operation error.
    /// This error is thrown when some operation cannot be performed, because it is not supported.
    unsupported,
    /// Alignment error.
    /// This is thrown when a pointer does not point to a properly aligned slice of memory.
    bad-align,
    /// Invalid HTTP error.
    /// This can be thrown when a method, URI, header, or status is not valid. This can also
    /// be thrown if a message head is too large.
    http-invalid,
    /// HTTP user error.
    /// This is thrown in cases where user code caused an HTTP error. For example, attempt to send
    /// a 1xx response code, or a request with a non-absolute URI. This can also be caused by
    /// an unexpected header: both `content-length` and `transfer-encoding`, for example.
    http-user,
    /// HTTP incomplete message error.
    /// This can be thrown when a stream ended unexpectedly.
    http-incomplete,
    /// A `None` error.
    /// This status code is used to indicate when an optional value did not exist, as opposed to
    /// an empty value.
    /// Note, this value should no longer be used, as we have explicit optional types now.
    optional-none,
    /// Message head too large.
    http-head-too-large,
    /// Invalid HTTP status.
    http-invalid-status,
    /// Limit exceeded
    ///
    /// This is returned when an attempt to allocate a resource has exceeded the maximum number of
    /// resources permitted. For example, creating too many response handles.
    limit-exceeded
  }
}

interface http-types {

  /// A tag indicating HTTP protocol versions.
  enum http-version {
    http09,
    http10,
    http11,
    h2,
    h3
  }

  flags content-encodings {
    gzip
  }

  /// Adjust how this requests's framing headers are determined.
  enum framing-headers-mode {
    automatic,
    manually-from-headers
  }

  enum tls-version {
    tls1,
    tls11,
    tls12,
    tls13
  }

  flags backend-config-options {
    reserved,
    host-override,
    connect-timeout,
    first-byte-timeout,
    between-bytes-timeout,
    use-tls,
    tls-min-version,
    tls-max-version,
    cert-hostname,
    ca-cert,
    ciphers,
    sni-hostname,
    dont-pool,
    client-cert,
    grpc,
    keepalive,
  }

  /// HTTP status codes.
  type http-status = u16;
}

/// Fastly UAP
interface uap {

  use types.{error};

  resource user-agent {
    family: func(max-len: u64) -> result<string, error>;
    major: func(max-len: u64) -> result<string, error>;
    minor: func(max-len: u64) -> result<string, error>;
    patch: func(max-len: u64) -> result<string, error>;
  }

  /// Parse a user agent string.
  parse: func(user-agent: list<u8>) -> result<user-agent, error>;
}

/// Fastly HTTP Body
interface http-body {

  use types.{error};
  use async-io.{handle as body-handle};

  enum write-end {
    back,
    front
  }

  append: func(dest: borrow<body-handle>, src: body-handle) -> result<_, error>;

  new: func() -> result<body-handle, error>;

  read: func(h: borrow<body-handle>, chunk-size: u32) -> result<list<u8>, error>;

  write: func(h: borrow<body-handle>, buf: list<u8>, end: write-end) -> result<u32, error>;

  /// Frees the body on the host.
  ///
  /// For streaming bodies, this is a _successful_ stream termination, which will signal
  /// via framing that the body transfer is complete.
  close: func(h: body-handle) -> result<_, error>;

  /// Frees a streaming body on the host _unsuccessfully_, so that framing makes clear that
  /// the body is incomplete.
  abandon: func(h: body-handle) -> result<_, error>;

  /// Returns a u64 body length if the length of a body is known, or `FastlyStatus::None`
  /// otherwise.
  ///
  /// If the length is unknown, it is likely due to the body arising from an HTTP/1.1 message with
  /// chunked encoding, an HTTP/2 or later message with no `content-length`, or being a streaming
  /// body.
  ///
  /// Note that receiving a length from this function does not guarantee that the full number of
  /// bytes can actually be read from the body. For example, when proxying a response from a
  /// backend, this length may reflect the `content-length` promised in the response, but if the
  /// backend connection is closed prematurely, fewer bytes may be delivered before this body
  /// handle can no longer be read.
  known-length: func(h: borrow<body-handle>) -> result<u64, error>;

  trailer-append: func(
    h: borrow<body-handle>,
    name: list<u8>,
    value: list<u8>,
  ) -> result<_, error>;

  trailer-names-get: func(
    h: borrow<body-handle>,
    max-len: u64,
    cursor: u32,
  ) -> result<option<tuple<list<u8>, option<u32>>>, error>;

  trailer-value-get: func(
    h: borrow<body-handle>,
    name: list<u8>,
    max-len: u64,
  ) -> result<option<list<u8>>, error>;

  trailer-values-get: func(
    h: borrow<body-handle>,
    name: list<u8>,
    max-len: u64,
    cursor: u32
  ) -> result<option<tuple<list<u8>, option<u32>>>, error>;
}

/// Fastly Log
interface log {

  use types.{error};

  /// A handle to a logging endpoint.
  resource handle {
    endpoint-get: static func(name: string) -> result<handle, error>;

    write: func(msg: list<u8>) -> result<u32, error>;
  }
}

/// Fastly HTTP Req
interface http-req {

  use types.{error};
  use http-types.{
    http-version,
    content-encodings, framing-headers-mode, backend-config-options, tls-version,
  };
  use secret-store.{secret-handle};
  use http-body.{body-handle};
  use http-resp.{response};
  use async-io.{handle as pending-request-handle};

  /// A handle to an HTTP request.
  resource request-handle {
    cache-override-set: func(
      tag: cache-override-tag,
      ttl: u32,
      stale-while-revalidate: u32,
      sk: option<list<u8>>
    ) -> result<_, error>;

    new: static func() -> result<request-handle, error>;

    header-names-get: func(
      max-len: u64,
      cursor: u32,
    ) -> result<option<tuple<list<u8>, option<u32>>>, error>;

    header-value-get: func(
      name: list<u8>,
      max-len: u64,
    ) -> result<option<list<u8>>, error>;

    header-values-get: func(
      name: list<u8>,
      max-len: u64,
      cursor: u32
    ) -> result<option<tuple<list<u8>, option<u32>>>, error>;

    header-values-set: func(
      name: list<u8>,
      /// contains multiple values separated by \0
      values: list<u8>
    ) -> result<_, error>;

    header-insert: func(name: list<u8>, value: list<u8>) -> result<_, error>;

    header-append: func(
      name: list<u8>,
      value: list<u8>,
    ) -> result<_, error>;

    header-remove: func(name: list<u8>) -> result<_, error>;

    method-get: func(max-len: u64) -> result<string, error>;

    method-set: func(method: string) -> result<_, error>;

    uri-get: func(max-len: u64) -> result<string, error>;

    uri-set: func(uri: string) -> result<_, error>;

    version-get: func() -> result<http-version, error>;

    version-set: func(version: http-version) -> result<_, error>;

    auto-decompress-response-set: func(
      encodings: content-encodings,
    ) -> result<_, error>;

    redirect-to-websocket-proxy: func(
      backend: string,
    ) -> result<_, error>;

    /// Adjust how this requests's framing headers are determined.
    framing-headers-mode-set: func(
      mode: framing-headers-mode,
    ) -> result<_, error>;

    /// Hostcall for Fastly Compute guests to inspect request HTTP traffic
    /// using the NGWAF lookaside service.
    inspect: func(
      b: borrow<body-handle>,
      options: inspect-config-options,
      info: inspect-config,
      max-len: u64
    ) -> result<list<u8>, error>;

    /// Instead of having this request cache in this service's space, use the
    /// cache of the named service
    on-behalf-of: func(
      service: string,
    ) -> result<_, error>;

    redirect-to-grip-proxy: func(
      backend: string,
    ) -> result<_, error>;
  }

  send: func(
    h: request-handle,
    b: body-handle,
    backend: string,
  ) -> result<response, error>;

  send-v2: func(
    h: request-handle,
    b: body-handle,
    backend: string,
  ) -> result<response, error-with-detail>;

  send-v3: func(
    h: request-handle,
    b: body-handle,
    backend: string,
  ) -> result<response, error-with-detail>;

  send-async: func(
    h: request-handle,
    b: body-handle,
    backend: string
  ) -> result<pending-request-handle, error>;

  send-async-v2: func(
    req-handle: request-handle,
    body-handle: body-handle,
    backend: string,
  ) -> result<pending-request-handle, error>;

  send-async-v2-streaming: func(
    req-handle: request-handle,
    body-handle: borrow<body-handle>,
    backend: string,
  ) -> result<pending-request-handle, error>;

  send-async-streaming: func(
    h: request-handle,
    b: borrow<body-handle>,
    backend: string
  ) -> result<pending-request-handle, error>;

  type request = tuple<request-handle, body-handle>;

  /// An override for response caching behavior.
  /// A zero value indicates that the origin response's cache control headers should be used.
  flags cache-override-tag {
    /// Do not cache the response to this request, regardless of the origin response's headers.
    pass,
    ttl,
    stale-while-revalidate,
    pci,
  }

  /// TLS client certificate verified result from downstream.
  enum client-cert-verify-result {
    /// Success value.
    ///
    /// This indicates that client certificate verified successfully.
    ok,
    /// bad certificate error.
    ///
    /// This error means the certificate is corrupt
    /// (e.g., the certificate signatures do not verify correctly).
    bad-certificate,
    /// certificate revoked error.
    ///
    /// This error means the client certificate is revoked by its signer.
    certificate-revoked,
    /// certificate expired error.
    ///
    /// This error means the client certificate has expired or is not currently valid.
    certificate-expired,
    /// unknown CA error.
    ///
    /// This error means the valid certificate chain or partial chain was received,
    /// but the certificate was not accepted because the CA certificate could not be
    /// located or could not be matched with a known trust anchor.
    unknown-ca,
    /// certificate missing error.
    ///
    /// This error means the client does not provide a certificate
    /// during the handshake..
    certificate-missing,
    /// certificate unknown error.
    ///
    /// This error means the client certificate was received, but some other (unspecified)
    /// issue arose in processing the certificate, rendering it unacceptable.
    certificate-unknown,
  }

  enum send-error-detail-tag {
      /// The $send_error_detail struct has not been populated.
      uninitialized,
      /// There was no send error.
      ok,
      /// The system encountered a timeout when trying to find an IP address for the backend
      /// hostname.
      dns-timeout,
      /// The system encountered a DNS error when trying to find an IP address for the backend
      /// hostname. The fields $dns_error_rcode and $dns_error_info_code may be set in the
      /// $send_error_detail.
      dns-error,
      /// The system cannot determine which backend to use, or the specified backend was invalid.
      destination-not-found,
      /// The system considers the backend to be unavailable; e.g., recent attempts to communicate
      /// with it may have failed, or a health check may indicate that it is down.
      destination-unavailable,
      /// The system cannot find a route to the next-hop IP address.
      destination-ip-unroutable,
      /// The system's connection to the backend was refused.
      connection-refused,
      /// The system's connection to the backend was closed before a complete response was
      /// received.
      connection-terminated,
      /// The system's attempt to open a connection to the backend timed out.
      connection-timeout,
      /// The system is configured to limit the number of connections it has to the backend, and
      /// that limit has been exceeded.
      connection-limit-reached,
      /// The system encountered an error when verifying the certificate presented by the backend.
      tls-certificate-error,
      /// The system encountered an error with the backend TLS configuration.
      tls-configuration-error,
      /// The system received an incomplete response to the request from the backend.
      http-incomplete-response,
      /// The system received a response to the request whose header section was considered too
      /// large.
      http-response-header-section-too-large,
      /// The system received a response to the request whose body was considered too large.
      http-response-body-too-large,
      /// The system reached a configured time limit waiting for the complete response.
      http-response-timeout,
      /// The system received a response to the request whose status code or reason phrase was
      /// invalid.
      http-response-status-invalid,
      /// The process of negotiating an upgrade of the HTTP version between the system and the
      /// backend failed.
      http-upgrade-failed,
      /// The system encountered an HTTP protocol error when communicating with the backend. This
      /// error will only be used when a more specific one is not defined.
      http-protocol-error,
      /// An invalid cache key was provided for the request.
      http-request-cache-key-invalid,
      /// An invalid URI was provided for the request.
      http-request-uri-invalid,
      /// The system encountered an unexpected internal error.
      internal-error,
      /// The system received a TLS alert from the backend. The field $tls_alert_id may be set in
      /// the $send_error_detail.
      tls-alert-received,
      /// The system encountered a TLS error when communicating with the backend, either during
      /// the handshake or afterwards.
      tls-protocol-error,
  }

  flags send-error-detail-mask {
      reserved,
      dns-error-rcode,
      dns-error-info-code,
      tls-alert-id,
  }

  record send-error-detail {
      tag: send-error-detail-tag,
      mask: send-error-detail-mask,
      dns-error-rcode: u16,
      dns-error-info-code: u16,
      tls-alert-id: u8,
  }

  record error-with-detail {
      detail: option<send-error-detail>,
      error: error,
  }

  flags inspect-config-options {
    reserved,
    corp,
    workspace,
  }

  record inspect-config {
    corp: string,
    workspace: string,
  }

  downstream-client-ip-addr: func() -> result<list<u8>, error>;

  downstream-server-ip-addr: func() -> result<list<u8>, error>;

  downstream-client-h2-fingerprint: func(max-len: u64) -> result<list<u8>, error>;

  downstream-client-request-id: func(max-len: u64) -> result<list<u8>, error>;

  downstream-client-oh-fingerprint: func(max-len: u64) -> result<list<u8>, error>;

  downstream-client-ddos-detected: func() -> result<u32, error>;

  downstream-tls-cipher-openssl-name: func(max-len: u64) -> result<list<u8>, error>;

  downstream-tls-protocol: func(max-len: u64) -> result<list<u8>, error>;

  downstream-tls-client-hello: func(max-len: u64) -> result<list<u8>, error>;

  downstream-tls-raw-client-certificate: func(max-len: u64) -> result<list<u8>, error>;

  downstream-tls-client-cert-verify-result: func() -> result<client-cert-verify-result, error>;

  downstream-tls-ja3-md5: func() -> result<list<u8>, error>;

  downstream-tls-ja4: func(max-len: u64) -> result<list<u8>, error>;

  downstream-compliance-region: func(max-len: u64) -> result<list<u8>, error>;

  original-header-names-get: func(
    max-len: u64,
    cursor: u32,
  ) -> result<option<tuple<list<u8>, option<u32>>>, error>;

  original-header-count: func() -> result<u32, error>;

  pending-req-poll: func(
    h: borrow<pending-request-handle>,
  ) -> result<option<response>, error-with-detail>;

  pending-req-wait: func(
    h: borrow<pending-request-handle>
  ) -> result<response, error-with-detail>;

  pending-req-select: func(
    h: list<borrow<pending-request-handle>>
  ) -> result<tuple<u32, result<response, send-error-detail>>, error>;

  /// Returns whether or not the original client request arrived with a
  /// Fastly-Key belonging to a user with the rights to purge content on this
  /// service.
  fastly-key-is-valid: func() -> result<bool, error>;

  close: func(h: request-handle) -> result<_, error>;

  upgrade-websocket: func(backend: string) -> result<_, error>;

  /// Deprecated; use `redirect-to-websocket-proxy` instead.
  redirect-to-websocket-proxy-deprecated: func(backend: string) -> result<_, error>;

  /// Deprecated; use `redirect-to-grip-proxy` instead.
  redirect-to-grip-proxy-deprecated: func(backend: string) -> result<_, error>;

  /// Create a backend for later use
  register-dynamic-backend: func(
    options: backend-config-options,
    config: dynamic-backend-config,
  ) -> result<_, error>;

  /// Create a backend for later use
  resource dynamic-backend-config {
    new: static func(
      prefix: string,
      target: string,
    ) -> dynamic-backend-config;

    host-override: func(value: string);
    connect-timeout: func(value: u32);
    first-byte-timeout: func(value: u32);
    between-bytes-timeout: func(value: u32);
    tls-min-version: func(value: tls-version);
    tls-max-version: func(value: tls-version);
    cert-hostname: func(value: string);
    ca-cert: func(value: string);
    ciphers: func(value: string);
    sni-hostname: func(value: string);
    client-cert: func(value: string);
    client-key: func(value: borrow<secret-handle>);
    http-keepalive-time-ms: func(value: u32);
    tcp-keepalive-enable: func(value: u32);
    tcp-keepalive-interval-secs: func(value: u32);
    tcp-keepalive-probes: func(value: u32);
    tcp-keepalive-time-secs: func(value: u32);
  }
}

/// Fastly HTTP Resp
interface http-resp {
  use types.{error};

  use http-types.{
    http-version, http-status,
    framing-headers-mode
  };
  use http-body.{body-handle};

  /// A handle to an HTTP response.
  resource response-handle {
    new: static func() -> result<response-handle, error>;

    header-names-get: func(
      max-len: u64,
      cursor: u32,
    ) -> result<option<tuple<list<u8>, option<u32>>>, error>;

    header-value-get: func(
      name: list<u8>,
      max-len: u64,
    ) -> result<option<list<u8>>, error>;

    header-values-get: func(
      name: list<u8>,
      max-len: u64,
      cursor: u32
    ) -> result<option<tuple<list<u8>, option<u32>>>, error>;

    header-values-set: func(
      name: list<u8>,
      /// contains multiple values separated by \0
      values: list<u8>
    ) -> result<_, error>;

    header-insert: func(
      name: list<u8>,
      value: list<u8>,
    ) -> result<_, error>;

    header-append: func(
      name: list<u8>,
      value: list<u8>,
    ) -> result<_, error>;

    header-remove: func(
      name: list<u8>,
    ) -> result<_, error>;

    version-get: func() -> result<http-version, error>;

    version-set: func(
      version: http-version,
    ) -> result<_, error>;

    status-get: func() -> result<http-status, error>;

    status-set: func(status: http-status) -> result<_, error>;

    /// Adjust how this response's framing headers are determined.
    framing-headers-mode-set: func(mode: framing-headers-mode)
-> result<_, error>;

    /// Adjust the response's connection reuse mode.
    http-keepalive-mode-set: func(mode: keepalive-mode) ->
result<_, error>;

    /// Hostcall for getting the destination IP used for this request.
    ///
    /// The buffer for the IP address must be 16 bytes. `addr_octets_out`
    /// will be set to 4 for IPv4 addresses, and 16 for IPv6.
    get-addr-dest-ip: func() -> result<list<u8>, error>;

    /// Hostcall for getting the destination port used for this request.
    get-addr-dest-port: func() -> result<u16, error>;
  }

  send-downstream: func(
    h: response-handle,
    b: body-handle,
  ) -> result<_, error>;

  send-downstream-streaming: func(
    h: response-handle,
    b: borrow<body-handle>,
  ) -> result<_, error>;

  close: func(h: response-handle) -> result<_, error>;

  type response = tuple<response-handle, body-handle>;

  enum keepalive-mode {
    automatic,
    no-keepalive,
  }
}

/// Fastly Dictionary
interface dictionary {

  use types.{error};

  /// A handle to an Edge Dictionary.
  resource handle {
    open: static func(name: string) -> result<handle, error>;

    get: func(
      key: string,
      max-len: u64,
    ) -> result<option<string>, error>;
  }
}

/// Fastly Geo
interface geo {
  use types.{error};

  lookup: func(addr-octets: list<u8>, max-len: u64) -> result<list<u8>, error>;
}

/// Fastly device detection
interface device-detection {
  use types.{error};

  lookup: func(user-agent: string, max-len: u64) -> result<option<list<u8>>, error>;
}

/// Fastly edge-rate-limiter
interface erl {
  use types.{error};

  check-rate: func(
    rc: string,
    entry: string,
    delta: u32,
    window: u32,
    limit: u32,
    pb: string,
    ttl: u32,
  ) -> result<u32, error>;

  ratecounter-increment: func(
    rc: string,
    entry: string,
    delta: u32,
  ) -> result<_, error>;

  ratecounter-lookup-rate: func(
    rc: string,
    entry: string,
    window: u32,
  ) -> result<u32, error>;

  ratecounter-lookup-count: func(
    rc: string,
    entry: string,
    duration: u32,
  ) -> result<u32, error>;

  penaltybox-add: func(
    pb: string,
    entry: string,
    ttl: u32,
  ) -> result<_, error>;

  penaltybox-has: func(
    pb: string,
    entry: string,
  ) -> result<u32, error>;
}

/// Fastly Object Store
interface object-store {

  use types.{error};
  use http-body.{body-handle};

  /// (DEPRECATED) A handle to an Object Store.
  resource handle {
    open: static func(name: string) -> result<option<handle>, error>;

    lookup: func(
      key: string,
    ) -> result<option<body-handle>, error>;

    lookup-async: func(
      key: string,
    ) -> result<pending-lookup-handle, error>;

    insert: func(
      key: string,
      body-handle: borrow<body-handle>,
    ) -> result<_, error>;

    insert-async: func(
      key: string,
      body-handle: borrow<body-handle>,
    ) -> result<pending-insert-handle, error>;

    delete-async: func(
      key: string,
    ) -> result<pending-delete-handle, error>;
  }
  /// (DEPRECATED) A handle to a pending Object Store lookup.
  resource pending-lookup-handle {}
  /// (DEPRECATED) A handle to a pending Object Store insert.
  resource pending-insert-handle {}
  /// (DEPRECATED) A handle to a pending Object Store delete.
  resource pending-delete-handle {}

  pending-lookup-wait: func(
    handle: pending-lookup-handle,
  ) -> result<option<body-handle>, error>;

  pending-insert-wait: func(
    handle: pending-insert-handle,
  ) -> result<_, error>;

  pending-delete-wait: func(
    handle: pending-delete-handle,
  ) -> result<_, error>;
}

/// Fastly KV Store (adapter)
///
/// -- find the component version in github.com:fastly/edge-storage
interface kv-store {

  use types.{error};
  use http-body.{body-handle};

  /// A handle to an KV Store.
  resource handle {
    open: static func(name: string) -> result<option<handle>, error>;

    lookup: func(
      key: list<u8>,
    ) -> result<lookup-handle, error>;

    insert: func(
      key: list<u8>,
      body-handle: borrow<body-handle>,
      mask: insert-config-options,
      config: insert-config,
    ) -> result<insert-handle, error>;

    delete: func(
      key: list<u8>,
    ) -> result<delete-handle, error>;

    %list: func(
      mask: list-config-options,
      options: list-config,
    ) -> result<list-handle, error>;
  }
  /// A handle to a KV Store lookup.
  resource lookup-handle {}
  /// A handle to a KV Store insert.
  resource insert-handle {}
  /// A handle to a KV Store delete.
  resource delete-handle {}
  /// A handle to a KV Store list.
  resource list-handle {}

  enum kv-status {
    /// There was no error.
    ok,
    /// KV store cannot or will not process the request due to something that is perceived to be a client error
    /// This will map to the api's 400 codes
    bad-request,
    /// KV store cannot find the requested resource
    /// This will map to the api's 404 codes
    not-found,
    /// KV store cannot fulfill the request, as definied by the client's prerequisites (ie. if-generation-match)
    /// This will map to the api's 412 codes
    precondition-failed,
    /// The size limit for a KV store key was exceeded.
    /// This will map to the api's 413 codes
    payload-too-large,
    /// The system encountered an unexpected internal error.
    /// This will map to all remaining http error codes
    internal-error,
    /// Too many requests have been made to the KV store.
    /// This will map to the api's 429 codes
    too-many-requests,
  }

  resource lookup-result {
    body: func() -> body-handle;
    metadata: func(max-len: u64) -> result<option<string>, error>;
    generation: func() -> u64;
  }

  lookup-wait: func(
    handle: lookup-handle,
  ) -> result<tuple<option<lookup-result>, kv-status>, error>;

  enum insert-mode {
    overwrite,
    add,
    append,
    prepend,
  }

  flags insert-config-options {
    reserved,
    background-fetch,
    if-generation-match,
    metadata,
    time-to-live-sec,
  }

  record insert-config {
    mode: insert-mode,
    if-generation-match: u64,
    metadata: string,
    time-to-live-sec: u32,
  }

  insert-wait: func(
    handle: insert-handle,
  ) -> result<kv-status, error>;

  delete-wait: func(
    handle: delete-handle,
  ) -> result<kv-status, error>;

  enum list-mode {
    strong,
    eventual,
  }

  flags list-config-options {
    reserved,
    cursor,
    limit,
    prefix,
  }

  record list-config {
    mode: list-mode,
    cursor: string,
    limit: u32,
    prefix: string,
  }

  list-wait: func(
    handle: list-handle,
  ) -> result<tuple<option<body-handle>, kv-status>, error>;
}

/// Fastly Secret Store
interface secret-store {

  use types.{error};

  /// A handle to an individual secret.
  resource secret-handle {
    from-bytes: static func(bytes: list<u8>) -> result<secret-handle, error>;

    plaintext: func(
      max-len: u64
    ) -> result<option<list<u8>>, error>;
  }

  /// A handle to a Secret Store.
  resource store-handle {
    open: static func(name: string) -> result<store-handle, error>;

    get: func(
      key: string,
    ) -> result<option<secret-handle>, error>;
  }
}

/// Fastly ACL
interface acl {

  use types.{error};
  use http-body.{body-handle};

  /// A handle to an ACL.
  resource acl-handle {
    open: static func(name: string) -> result<acl-handle, error>;

    lookup: func(
      ip-octets: list<u8>,
      ip-len: u64,
    ) -> result<tuple<option<body-handle>, acl-error>, error>;
  }

  enum acl-error {
    /// The $acl_error has not been initialized.
    uninitialized,
    /// There was no error.
    ok,
    /// This will map to the api's 204 code.
    /// It indicates that the request succeeded, yet returned nothing.
    no-content,
    /// This will map to the api's 429 code.
    /// Too many requests have been made.
    too-many-requests,
  }
}

/// Fastly backend
interface backend {
  use types.{error};
  use http-types.{tls-version};

  type timeout-ms = u32;
  type timeout-secs = u32;
  type probe-count = u32;

  exists: func(backend: string) -> result<bool, error>;

  enum backend-health {
    unknown,
    healthy,
    unhealthy,
  }

  is-healthy: func(backend: string) -> result<backend-health, error>;

  /// Returns `true` if the backend is a "dynamic" backend.
  is-dynamic: func(backend: string) -> result<bool, error>;

  /// Get the host of this backend.
  get-host: func(backend: string, max-len: u64) -> result<string, error>;

  /// Get the "override host" for this backend.
  ///
  /// This is used to change the `Host` header sent to the backend. See the
  /// Fastly documentation oh this topic here: https://docs.fastly.com/en/guides/specifying-an-override-host
  get-override-host: func(
    backend: string,
    max-len: u64,
  ) -> result<option<list<u8>>, error>;

  /// Get the remote TCP port of the backend connection for the request.
  get-port: func(backend: string) -> result<u16, error>;

  /// Get the connection timeout of the backend.
  get-connect-timeout-ms: func(backend: string) -> result<u32, error>;

  /// Get the first byte timeout of the backend.
  get-first-byte-timeout-ms: func(backend: string) -> result<u32, error>;

  /// Get the between byte timeout of the backend.
  get-between-bytes-timeout-ms: func(backend: string) -> result<u32, error>;

  /// Returns `true` if the backend is configured to use TLS.
  is-tls: func(backend: string) -> result<bool, error>;

  /// Get the minimum TLS version this backend will use.
  get-tls-min-version: func(backend: string) -> result<option<tls-version>, error>;

  /// Get the maximum TLS version this backend will use.
  get-tls-max-version: func(backend: string) -> result<option<tls-version>, error>;

  get-http-keepalive-time: func(
    backend: string,
  ) -> result<timeout-ms, error>;

  get-tcp-keepalive-enable: func(
    backend: string,
  ) -> result<bool, error>;

  get-tcp-keepalive-interval: func(
    backend: string,
  ) -> result<timeout-secs, error>;

  get-tcp-keepalive-probes: func(
    backend: string,
  ) -> result<probe-count, error>;

  get-tcp-keepalive-time: func(
    backend: string,
  ) -> result<timeout-secs, error>;
}

/// Fastly Async IO
interface async-io {
  use types.{error};

  /// A handle to an object supporting generic async operations.
  /// Can be a `BodyHandle`, `PendingRequestHandle`, or `BusyHandle`.
  ///
  /// Each async item has an associated I/O action:
  ///
  /// * Pending requests: awaiting the response headers / `Response` object
  /// * Normal bodies: reading bytes from the body
  /// * Streaming bodies: writing bytes to the body
  ///
  /// For writing bytes, note that there is a large host-side buffer that bytes can eagerly be written
  /// into, even before the origin itself consumes that data.
  resource handle {
    /// Returns 1 if the given async item is "ready" for its associated I/O action, 0 otherwise.
    ///
    /// If an object is ready, the I/O action is guaranteed to complete without blocking.
    ///
    /// Valid object handles includes bodies and pending requests. See the `async_item_handle`
    /// definition for more details, including what I/O actions are associated with each handle
    /// type.
    is-ready: func() -> result<bool, error>;
  }

  /// Blocks until one of the given objects is ready for I/O, or the optional timeout expires.
  ///
  /// Valid object handles includes bodies and pending requests. See the `async_item_handle`
  /// definition for more details, including what I/O actions are associated with each handle
  /// type.
  ///
  /// The timeout is specified in milliseconds, or 0 if no timeout is desired.
  ///
  /// Returns the _index_ (not handle!) of the first object that is ready, or
  /// none if the timeout expires before any objects are ready for I/O.
  select: func(hs: list<borrow<handle>>, timeout-ms: u32) -> result<option<u32>, error>;
}

/// Fastly Purge
///
/// See the [Fastly purge documentation] for details.
///
/// [Fastly purge documentation]: https://www.fastly.com/documentation/guides/concepts/edge-state/cache/purging/
interface purge {

  use types.{error};

  flags purge-options-mask {
    soft-purge,
    /// all ret_buf fields must be populated
    ret-buf
  }

  /// Purge a surrogate key for the current service.
  ///
  /// A surrogate key can be a max of 1024 characters.
  /// A surrogate key must contain only printable ASCII characters (those between `0x21` and `0x7E`, inclusive).
  ///
  /// Returns a JSON purge response as in https://developer.fastly.com/reference/api/purging/#purge-tag
  purge-surrogate-key: func(
    surrogate-keys: string,
    purge-options: purge-options-mask,
    max-len: u64,
  ) -> result<option<string>, error>;
}

/// Fastly Cache
interface cache {

  use types.{error};
  use http-body.{body-handle};
  use http-req.{request-handle};

  /// The outcome of a cache lookup (either bare or as part of a cache transaction)
  resource handle {
    /// Performs a non-request-collapsing cache lookup.
    ///
    /// Returns a result without waiting for any request collapsing that may be ongoing.
    lookup: static func(
      key: list<u8>,
      mask: lookup-options-mask,
      options: lookup-options,
    ) -> result<handle, error>;

    /// The entrypoint to the request-collapsing cache transaction API.
    ///
    /// This operation always participates in request collapsing and may return stale objects. To bypass
    /// request collapsing, use `lookup` and `insert` instead.
    transaction-lookup: static func(
      key: list<u8>,
      mask: lookup-options-mask,
      options: lookup-options,
    ) -> result<handle, error>;

    /// The entrypoint to the request-collapsing cache transaction API, returning instead of waiting on busy.
    ///
    /// This operation always participates in request collapsing and may return stale objects. To bypass
    /// request collapsing, use `lookup` and `insert` instead.
    transaction-lookup-async: static func(
      key: list<u8>,
      mask: lookup-options-mask,
      options: lookup-options,
    ) -> result<busy-handle, error>;

    /// Insert an object into the cache with the given metadata.
    ///
    /// Can only be used in if the cache handle state includes the `must-insert-or-update` flag.
    ///
    /// The returned handle is to a streaming body that is used for writing the object into
    /// the cache.
    transaction-insert: func(
      mask: write-options-mask,
      options: write-options,
    ) -> result<body-handle, error>;

    /// Insert an object into the cache with the given metadata, and return a readable stream of the
    /// bytes as they are stored.
    ///
    /// This helps avoid the "slow reader" problem on a teed stream, for example when a program wishes
    /// to store a backend request in the cache while simultaneously streaming to a client in an HTTP
    /// response.
    ///
    /// The returned body handle is to a streaming body that is used for writing the object _into_
    /// the cache. The returned cache handle provides a separate transaction for reading out the
    /// newly cached object to send elsewhere.
    transaction-insert-and-stream-back: func(
      mask: write-options-mask,
      options: write-options,
    ) -> result<tuple<body-handle, handle>, error>;

    /// Update the metadata of an object in the cache without changing its data.
    ///
    /// Can only be used in if the cache handle state includes both of the flags:
    /// - `found`
    /// - `must-insert-or-update`
    transaction-update: func(
      mask: write-options-mask,
      options: write-options,
    ) -> result<_, error>;

    get-state: func() -> result<lookup-state, error>;

    /// Gets the user metadata of the found object, returning None if no object
    /// was found.
    get-user-metadata: func(max-len: u64) -> result<option<list<u8>>, error>;

    /// Gets a range of the found object body, returning the `optional-none` error if there
    /// was no found object.
    ///
    /// The returned `body_handle` must be closed before calling this function again on the same
    /// `cache_handle`.
    ///
    /// Note: until the CacheD protocol is adjusted to fully support this functionality,
    /// the body of objects that are past the stale-while-revalidate period will not
    /// be available, even when other metadata is.
    get-body: func(
      mask: get-body-options-mask,
      options: get-body-options,
    ) -> result<body-handle, error>;

    /// Gets the content length of the found object, returning the `$none` error if there
    /// was no found object, or no content length was provided.
    get-length: func() -> result<u64, error>;

    /// Gets the configured max age of the found object, returning the `$none` error if there
    /// was no found object.
    get-max-age-ns: func() -> result<u64, error>;

    /// Gets the configured stale-while-revalidate period of the found object, returning the
    /// `$none` error if there was no found object.
    get-stale-while-revalidate-ns: func() -> result<u64, error>;

    /// Gets the age of the found object, returning the `$none` error if there
    /// was no found object.
    get-age-ns: func() -> result<u64, error>;

    /// Gets the number of cache hits for the found object, returning the `$none` error if there
    /// was no found object.
    get-hits: func() -> result<u64, error>;

    /// Cancel an obligation to provide an object to the cache.
    ///
    /// Useful if there is an error before streaming is possible, e.g. if a backend is unreachable.
    transaction-cancel: func() -> result<_, error>;
  }
  /// Handle that can be used to check whether or not a cache lookup is waiting on another client.
  use async-io.{handle as busy-handle};

  type cache-replace-handle = handle;

  /// The entrypoint to the replace API.
  ///
  /// This operation always participates in request collapsing and may return stale objects.
  replace: func(
    key: list<u8>,
    mask: replace-options-mask,
    options: replace-options,
  ) -> result<cache-replace-handle, error>;

  /// Replace an object in the cache with the given metadata
  ///
  /// The returned handle is to a streaming body that is used for writing the object into
  /// the cache.
  replace-insert: func(
    handle: borrow<cache-replace-handle>,
    mask: write-options-mask,
    options: write-options,
  ) -> result<body-handle, error>;

  /// Gets the age of the existing object during replace, returning
  /// `None` if there was no object.
  replace-get-age-ns: func(
    handle: borrow<cache-replace-handle>,
  ) -> result<option<duration-ns>, error>;

  /// Gets a range of the existing object body, returning `None` if there
  /// was no existing object.
  ///
  /// The returned `body_handle` must be closed before calling this function
  /// again on the same `cache_replace_handle`.
  replace-get-body: func(
    handle: borrow<cache-replace-handle>,
    mask: get-body-options-mask,
    options: get-body-options,
  ) -> result<option<body-handle>, error>;

  /// Gets the number of cache hits for the existing object during replace,
  /// returning `None` if there was no object.
  replace-get-hits: func(
    handle: borrow<cache-replace-handle>,
  ) -> result<option<cache-hit-count>, error>;

  /// Gets the content length of the existing object during replace,
  /// returning `None` if there was no object, or no content
  /// length was provided.
  replace-get-length: func(
    handle: borrow<cache-replace-handle>,
  ) -> result<option<object-length>, error>;

  /// Gets the configured max age of the existing object during replace,
  /// returning the `$none` error if there was no object.
  replace-get-max-age-ns: func(
    handle: borrow<cache-replace-handle>,
  ) -> result<option<duration-ns>, error>;

  /// Gets the configured stale-while-revalidate period of the existing
  /// object during replace, returning the `$none` error if there was no
  /// object.
  replace-get-stale-while-revalidate-ns: func(
    handle: borrow<cache-replace-handle>,
  ) -> result<option<duration-ns>, error>;

  /// Gets the lookup state of the existing object during replace, returning
  /// the `$none` error if there was no object.
  replace-get-state: func(
    handle: borrow<cache-replace-handle>,
  ) -> result<option<lookup-state>, error>;

  /// Gets the user metadata of the existing object during replace, returning
  /// the `$none` error if there was no object.
  replace-get-user-metadata: func(
    handle: borrow<cache-replace-handle>,
    max-len: u64,
  ) -> result<option<list<u8>>, error>;

  type object-length = u64;
  type duration-ns = u64;
  type cache-hit-count = u64;

  flags lookup-options-mask {
    reserved,
    request-headers,
    service-id,
    always-use-requested-range,
  }

  /// Extensible options for cache lookup operations; currently used for both `lookup` and `transaction_lookup`.
  record lookup-options {
    /// A full request handle, but used only for its headers
    ///
    /// May be `none` if the `request-headers` option isn't enabled.
    ///
    request-headers: option<borrow<request-handle>>,

    service-id: string,
  }

  /// Options mask for `http_cache_write_options`.
  flags write-options-mask {
    reserved,
    /// Only allowed for non-transactional `insert`
    request-headers,
    vary-rule,
    initial-age-ns,
    stale-while-revalidate-ns,
    surrogate-keys,
    length,
    user-metadata,
    sensitive-data,
    edge-max-age-ns,
    service-id,
  }

  /// Configuration for several hostcalls that write to the cache:
  /// - `insert`
  /// - `transaction-insert`
  /// - `transaction-insert-and-stream-back`
  /// - `transaction-update`
  ///
  /// Some options are only allowed for certain of these hostcalls; see `cache-write-options-mask`.
  record write-options {
    /// this is a required field; there's no flag for it
    max-age-ns: duration-ns,
    /// a full request handle, but used only for its headers
    request-headers: option<borrow<request-handle>>,
    /// a list of header names separated by spaces
    vary-rule: string,
    /// The initial age of the object in nanoseconds (default: 0).
    ///
    /// This age is used to determine the freshness lifetime of the object as well as to
    /// prioritize which variant to return if a subsequent lookup matches more than one vary rule
    initial-age-ns: duration-ns,
    stale-while-revalidate-ns: duration-ns,
    /// a list of surrogate keys separated by spaces
    surrogate-keys: string,
    length: object-length,
    user-metadata: list<u8>,
    edge-max-age-ns: duration-ns,
    service-id: string,
  }

  flags get-body-options-mask {
    reserved,
    %from,
    to,
  }

  record get-body-options {
    %from: u64,
    to: u64,
  }

  /// The status of this lookup (and potential transaction)
  flags lookup-state {
    /// a cached object was found
    found,
    /// the cached object is valid to use (implies found)
    usable,
    /// the cached object is stale (but may or may not be valid to use)
    stale,
    /// this client is requested to insert or revalidate an object
    must-insert-or-update,
  }

  /// Performs a non-request-collapsing cache insertion (or update).
  ///
  /// The returned handle is to a streaming body that is used for writing the object into
  /// the cache.
  insert: func(
    key: list<u8>,
    options-mask: write-options-mask,
    options: write-options,
  ) -> result<body-handle, error>;

  /// Continues the lookup transaction from which the given busy handle was returned,
  /// waiting for the leader transaction if request collapsed, and returns a cache handle.
  cache-busy-handle-wait: func(
    handle: borrow<busy-handle>,
  ) -> result<handle, error>;

  /// Close an interaction with the cache that has not yet finished request collapsing.
  close-busy: func(handle: busy-handle) -> result<_, error>;

  /// Close an ongoing interaction with the cache.
  ///
  /// If the cache handle state includes the `must-insert-or-update` (and hence no insert or
  /// update has been performed), closing the handle cancels any request collapsing, potentially
  /// choosing a new waiter to perform the insertion/update.
  close: func(handle: handle) -> result<_, error>;

  flags replace-options-mask {
    reserved,
    request-headers,
    replace-strategy,
    service-id,
    always-use-requested-range,
  }

  /// Extensible options for cache replace operations
  record replace-options {
    /// a full request handle, but used only for its headers
    request-headers: option<borrow<request-handle>>,
    replace-strategy: replace-strategy,
    service-id: string,
  }

  enum replace-strategy {
    immediate,
    immediate-force-miss,
    wait,
  }
}

/// Proposed hostcall interface for the HTTP Cache API
///
/// Overall, this should look very familiar to users of the Core Cache API. The primary differences
/// are:
///
/// - HTTP `request_handle`s and `response_handle`s are used rather than relying on the user to
///   encode headers, status codes, etc in `user_metadata`.
///
/// - Convenience functions specific to HTTP semantics are provided, such as `is_request_cacheable`,
///   `get_suggested_backend_request`, `get_suggested_cache_options`, and
///   `transaction_record_not_cacheable`.
///
/// The HTTP-specific behavior of these functions is intended to support applications that match the
/// normative guidance in RFC 9111. For example, `is_request_cacheable` returns `false` for `POST`
/// requests. However, this answer along with those of many of these functions explicitly provide
/// _suggestions_; they do not necessarily need to be followed if custom behavior is required, such
/// as caching `POST` responses when the application author knows that to be safe.
///
/// The starting points for this API are `lookup` (no request collapsing) and `transaction_lookup`
/// (request collapsing).
interface http-cache {
  use types.{error};
  use http-body.{body-handle};
  use http-req.{request-handle};
  use http-resp.{response-handle};
  use cache.{lookup-state, object-length, duration-ns, cache-hit-count};

  /// A handle to an HTTP Cache transaction.
  resource cache-handle {
    /// Perform a cache lookup based on the given request without participating in request
    /// collapsing.
    ///
    /// The request is not consumed.
    lookup: static func(
      req-handle: borrow<request-handle>,
      options-mask: cache-lookup-options-mask,
      options: cache-lookup-options,
    ) -> result<cache-handle, error>;

    /// Perform a cache lookup based on the given request.
    ///
    /// This operation always participates in request collapsing and may return an obligation to
    /// insert or update responses, and/or stale responses. To bypass request collapsing, use
    /// `lookup` instead.
    ///
    /// The request is not consumed.
    transaction-lookup: static func(
      req-handle: borrow<request-handle>,
      options-mask: cache-lookup-options-mask,
      options: cache-lookup-options,
    ) -> result<cache-handle, error>;

    /// Insert a response into the cache with the given options, returning a streaming body handle
    /// that is ready for writing or appending.
    ///
    /// Can only be used if the cache handle state includes the `$must_insert_or_update` flag.
    ///
    /// The response is consumed.
    transaction-insert: func(
      resp-handle: response-handle,
      options-mask: cache-write-options-mask,
      options: cache-write-options,
    ) -> result<body-handle, error>;

    /// Insert a response into the cache with the given options, and return a fresh cache handle
    /// that can be used to retrieve and stream the response while it's being inserted.
    ///
    /// This helps avoid the "slow reader" problem on a teed stream, for example when a program wishes
    /// to store a backend request in the cache while simultaneously streaming to a client in an HTTP
    /// response.
    ///
    /// The response is consumed.
    transaction-insert-and-stream-back: func(
      resp-handle: response-handle,
      options-mask: cache-write-options-mask,
      options: cache-write-options,
    ) -> result<tuple<body-handle, cache-handle>, error>;

    /// Update freshness lifetime, response headers, and caching settings without updating the
    /// response body.
    ///
    /// Can only be used in if the cache handle state includes both of the flags:
    /// - `$found`
    /// - `$must_insert_or_update`
    ///
    /// The response is consumed.
    transaction-update: func(
      resp-handle: response-handle,
      options-mask: cache-write-options-mask,
      options: cache-write-options,
    ) -> result<_, error>;

    /// Update freshness lifetime, response headers, and caching settings without updating the
    /// response body, and return a fresh cache handle that can be used to retrieve and stream the
    /// stored response.
    ///
    /// Can only be used in if the cache handle state includes both of the flags:
    /// - `$found`
    /// - `$must_insert_or_update`
    ///
    /// The response is consumed.
    transaction-update-and-return-fresh: func(
      resp-handle: response-handle,
      options-mask: cache-write-options-mask,
      options: cache-write-options,
    ) -> result<cache-handle, error>;

    /// Disable request collapsing and response caching for this cache entry.
    ///
    /// In Varnish terms, this function stores a hit-for-pass object.
    ///
    /// Only the max age and, optionally, the vary rule are read from the options mask and struct
    /// for this function.
    transaction-record-not-cacheable: func(
      options-mask: cache-write-options-mask,
      options: cache-write-options,
    ) -> result<_, error>;

    /// Prepare a suggested request to make to a backend to satisfy the looked-up request.
    ///
    /// If there is a stored, stale response, this suggested request may be for revalidation. If the
    /// looked-up request is ranged, the suggested request will be unranged in order to try caching
    /// the entire response.
    get-suggested-backend-request: func() -> result<request-handle, error>;

    /// Prepare a suggested set of cache write options for a given request and response pair.
    ///
    /// The ABI of this function includes several unusual types of input and output parameters.
    ///
    /// The bits set in the `options_mask` input parameter describe which cache options the guest is
    /// requesting that the host provide.
    ///
    /// The `options` input parameter allows the guest to provide output parameters for
    /// pointer/length options. When the corresponding bit is set in `options_mask`, the pointer and
    /// length should be set in this record to be used by the host to provide the output.
    ///
    /// The `options_mask_out` output parameter is only used by the host to indicate the status of
    /// pointer/length data in the `options_out` record. The flag for a given pointer/length
    /// parameter is set by the host if the corresponding flag was set in `options_mask`, and the
    /// value is present in the suggested options. If the host returns a status of `$buflen`, the
    /// same set of flags will be set, but the length value of the corresponding fields in
    /// `options_out` are set to the lengths that would be required to read the full value from the
    /// host on a subsequent call.
    ///
    /// The `options_out` output parameter is where the host writes the suggested options that were
    /// requested by the guest in `options_mask`. For pointer/length data, if there was enough room
    /// to write the suggested option, the length field will contain the length of the data actually
    /// written, while the pointer field will match the input pointer.
    ///
    /// The response is not consumed.
    get-suggested-cache-options: func(
      response: borrow<response-handle>,
    ) -> result<suggested-cache-options, error>;

    /// Adjust a response into the appropriate form for storage and provides a storage action recommendation.
    ///
    /// For example, if the looked-up request contains conditional headers, this function will
    /// interpret a `304 Not Modified` response for revalidation by updating headers.
    ///
    /// In addition to the updated response, this function returns the recommended storage action.
    prepare-response-for-storage: func(
      response: borrow<response-handle>,
    ) -> result<tuple<storage-action, response-handle>, error>;

    /// Retrieve a stored response from the cache, returning the `$none` error if there was no found
    /// response.
    ///
    /// If `transform_for_client` is set, the response will be adjusted according to the looked-up
    /// request. For example, a response retrieved for a range request may be transformed into a
    /// `206 Partial Content` response with an appropriate `content-range` header.
    get-found-response: func(
      transform-for-client: u32,
    ) -> result<tuple<response-handle, body-handle>, error>;

    /// Get the state of a cache transaction.
    ///
    /// Primarily useful after performing the lookup to determine what subsequent operations are
    /// possible and whether any insertion or update obligations exist.
    get-state: func(
    ) -> result<lookup-state, error>;

    /// Get the length of the found response, returning the `$none` error if there was no found
    /// response or no length was provided.
    get-length: func() -> result<object-length, error>;

    /// Get the configured max age of the found response in nanoseconds, returning the `$none` error
    /// if there was no found response.
    get-max-age-ns: func() -> result<duration-ns, error>;

    /// Get the configured stale-while-revalidate period of the found response in nanoseconds,
    /// returning the `$none` error if there was no found response.
    get-stale-while-revalidate-ns: func(
    ) -> result<duration-ns, error>;

    /// Get the age of the found response in nanoseconds, returning the `$none` error if there was
    /// no found response.
    get-age-ns: func() -> result<duration-ns, error>;

    /// Get the number of cache hits for the found response, returning the `$none` error if there
    /// was no found response.
    ///
    /// Note that this figure only reflects hits for a stored response in a particular cache server
    /// or cluster, not the entire Fastly network.
    get-hits: func() -> result<cache-hit-count, error>;

    /// Get whether a found response is marked as containing sensitive data, returning the `$none`
    /// error if there was no found response.
    get-sensitive-data: func() -> result<bool, error>;

    /// Get the surrogate keys of the found response, returning the `$none` error if there was no
    /// found response.
    ///
    /// The output is a list of surrogate keys separated by spaces.
    ///
    /// If the guest-provided output parameter is not long enough to contain the full list of
    /// surrogate keys, the required size is written by the host to `nwritten_out` and the `$buflen`
    /// error is returned.
    get-surrogate-keys: func(
      max-len: u64,
    ) -> result<list<u8>, error>;

    /// Get the vary rule of the found response, returning the `$none` error if there was no found
    /// response.
    ///
    /// The output is a list of header names separated by spaces.
    ///
    /// If the guest-provided output parameter is not long enough to contain the full list of
    /// surrogate keys, the required size is written by the host to `nwritten_out` and the `$buflen`
    /// error is returned.
    get-vary-rule: func(
      max-len: u64,
    ) -> result<list<u8>, error>;

    /// Abandon an obligation to provide a response to the cache.
    ///
    /// Useful if there is an error before streaming is possible, e.g. if a backend is unreachable.
    ///
    /// If there are other requests collapsed on this transaction, one of those other requests will
    /// be awoken and given the obligation to provide a response. Note that if subsequent requests
    /// are unlikely to yield cacheable responses, this may lead to undesired serialization of
    /// requests. Consider using `transaction_record_not_cacheable` to make lookups for this request
    /// bypass the cache.
    transaction-abandon: func() -> result<_, error>;
  }

  /// The suggested action to take for spec-recommended behavior following
  /// `prepare_response_for_storage`.
  enum storage-action {
    /// Insert the response into cache (`transaction_insert*`).
    insert,
    /// Update the stale response in cache (`transaction_update*`).
    update,
    /// Do not store this response.
    do-not-store,
    /// Do not store this response, and furthermore record its non-cacheability for other pending
    /// requests (`transaction_record_not_cacheable`).
    record-uncacheable,
  }

  /// Non-required options for cache lookups.
  ///
  /// This record is always provided along with an `http_cache_lookup_options_mask` value that
  /// indicates which of the fields in this record are valid.
  record cache-lookup-options {
    /// Cache key to use in lieu of the automatically-generated cache key based on the request's
    /// properties.
    override-key: list<u8>,
  }

  /// Options mask for `http_cache_lookup_options`.
  flags cache-lookup-options-mask {
    reserved,
    override-key,
  }

  flags cache-write-options-mask {
    reserved,
    vary-rule,
    initial-age-ns,
    stale-while-revalidate-ns,
    surrogate-keys,
    length,
    sensitive-data,
  }

  /// Options for cache insertions and updates.
  ///
  /// This record is always provided along with an `http_cache_write_options_mask` value that
  /// indicates which of the fields in this record are valid.
  record cache-write-options {
    /// The maximum age of the response before it is considered stale, in nanoseconds.
    ///
    /// This field is required; there is no flag for it in `http_cache_write_options_mask`.
    max-age-ns: duration-ns,

    /// A list of header names to use when calculating variants for this response.
    ///
    /// The format is a string containing header names separated by spaces.
    vary-rule: string,

    /// The initial age of the response in nanoseconds.
    ///
    /// If this field is not set, the default value is zero.
    ///
    /// This age is used to determine the freshness lifetime of the response as well as to
    /// prioritize which variant to return if a subsequent lookup matches more than one vary rule
    initial-age-ns: duration-ns,

    /// The maximum duration after `max_age` during which the response may be delivered stale
    /// while being revalidated, in nanoseconds.
    ///
    /// If this field is not set, the default value is zero.
    stale-while-revalidate-ns: duration-ns,

    /// A list of surrogate keys that may be used to purge this response.
    ///
    /// The format is a string containing [valid surrogate
    /// keys](https://www.fastly.com/documentation/reference/http/http-headers/Surrogate-Key/)
    /// separated by spaces.
    ///
    /// If this field is not set, no surrogate keys will be associated with the response. This
    /// means that the response cannot be purged except via a purge-all operation.
    surrogate-keys: string,

    /// The length of the response body.
    ///
    /// If this field is not set, the length of the body is treated as unknown.
    ///
    /// When possible, this field should be set so that other clients waiting to retrieve the
    /// body have enough information to synthesize a `content-length` even before the complete
    /// body is inserted to the cache.
    length: object-length,
  }

  /// Determine whether a request is cacheable per conservative RFC 9111 semantics.
  ///
  /// In particular, this function checks whether the request method is `GET` or `HEAD`, and
  /// considers requests with other methods uncacheable. Applications where it is safe to cache
  /// responses to other methods should consider using their own cacheability check instead of
  /// this function.
  is-request-cacheable: func(req-handle: borrow<request-handle>) -> result<bool, error>;

  /// Retrieves the default cache key for the request.
  ///
  /// The `$key_out` parameter must point to an array of size `key_out_len`.
  ///
  /// If the guest-provided output parameter is not long enough to contain the full key,
  /// the required size is written by the host to `nwritten_out` and the `$buflen`
  /// error is returned.
  ///
  /// At the moment, HTTP cache keys must always be 32 bytes.
  get-suggested-cache-key: func(
    req-handle: borrow<request-handle>,
    max-len: u64,
  ) -> result<list<u8>, error>;

  /// Close an ongoing interaction with the cache.
  ///
  /// If the cache handle state includes `$must_insert_or_update` (and hence no insert or update
  /// has been performed), closing the handle cancels any request collapsing, potentially choosing
  /// a new waiter to perform the insertion/update.
  ///
  /// This may be passed either a `handle` or a `cache-replace-handle`.
  close: func(
    handle: cache-handle,
  ) -> result<_, error>;

  resource suggested-cache-options {
    max-age-ns: func() -> duration-ns;
    vary-rule: func(max-len: u64) -> result<list<u8>, error>;
    initial-age-ns: func() -> duration-ns;
    stale-while-revalidate-ns: func() -> duration-ns;
    surrogate-keys: func(max-len: u64) -> result<list<u8>, error>;
    length: func() -> option<object-length>;
    sensitive-data: func() -> bool;
  }
}

interface config-store {
  use types.{error};

  /// A handle to an Config Store.
  resource handle {
    /// Attempt to open the named config store.
    open: static func(name: string) -> result<handle, error>;

    /// Fetch a value from the config store, returning `None` if it doesn't exist.
    get: func(
      key: string,
      max-len: u64,
    ) -> result<option<string>, error>;
  }
}

interface shielding {
  use types.{error};

  shield-info: func(
    name: string,
    max-len: u64,
  ) -> result<list<u8>, error>;

  flags shield-backend-options-mask {
    reserved,
    cache-key,
  }

  record shield-backend-options {
    cache-key: string,
  }

  backend-for-shield: func(
    name: string,
    options-mask: shield-backend-options-mask,
    options: shield-backend-options,
    max-len: u64,
  ) -> result<string, error>;
}

/// Fastly Image Optimizer
interface image-optimizer {

  use http-body.{body-handle};
  use http-req.{request-handle};
  use http-resp.{response};
  use types.{error};

  flags image-optimizer-transform-config-options {
    reserved,
    sdk-claims-opts,
  }

  record image-optimizer-transform-config {
    /// Contains any Image Optimizer API parameters that were set
    /// as well as the Image Optimizer region the request is meant for.
    sdk-claims-opts: string,
  }

  enum image-optimizer-error-tag {
    uninitialized,
    ok,
    error,
    warning,
  }

  record image-optimizer-error-detail {
    tag: image-optimizer-error-tag,
    message: list<u8>,
  }

  transform-image-optimizer-request: func(
    origin-image-request: borrow<request-handle>,
    origin-image-request-body: option<body-handle>,
    origin-image-request-backend: string,
    io-transform-config-mask: image-optimizer-transform-config-options,
    io-transform-config: image-optimizer-transform-config,
    io-error-detail: image-optimizer-error-detail,
  ) -> result<response, error>;
}


interface reactor {
  use http-body.{body-handle};
  use http-req.{request-handle};

  /// Serve the given request
  ///
  /// response handle not currently returned, because in the case of a streamed response
  /// send downstream must be fully streamed due to the run to completion semantics.
  serve: func(req: request-handle, body: body-handle) -> result;
}

interface compute-runtime {
  use types.{error};

  type vcpu-ms = u64;

  get-vcpu-ms: func() -> result<vcpu-ms, error>;
}

world compute {
  import wasi:clocks/wall-clock@0.2.0;
  import wasi:clocks/monotonic-clock@0.2.0;
  import wasi:io/error@0.2.0;
  import wasi:io/streams@0.2.0;
  import wasi:random/random@0.2.0;
  import wasi:cli/environment@0.2.0;
  import wasi:cli/exit@0.2.0;
  import wasi:cli/stdout@0.2.0;
  import wasi:cli/stderr@0.2.0;
  import wasi:cli/stdin@0.2.0;

  // public interfaces
  import acl;
  import async-io;
  import backend;
  import cache;
  import compute-runtime;
  import dictionary;
  import geo;
  import device-detection;
  import erl;
  import http-body;
  import http-req;
  import http-resp;
  import image-optimizer;
  import log;
  import kv-store;
  import object-store;
  import purge;
  import secret-store;
  import config-store;
  import uap;

  // experimental interfaces
  import http-cache;
  import shielding;

  export reactor;
}
